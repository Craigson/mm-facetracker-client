{"ast":null,"code":"var _jsxFileName = \"/Users/craigpickard/Dev/web/hbo-client/src/components/FaceTracker.js\";\nimport React, { useEffect, useState, Fragment } from \"react\";\nimport * as facemesh from \"@tensorflow-models/facemesh\";\nimport _isNil from \"lodash/isNil\";\nimport { TRIANGULATION } from \"./triangulation\";\nimport { findByLabelText } from \"@testing-library/react\"; // const useAnimationFrame = (callback) => {\n//   // Use useRef for mutable variables that we want to persist\n//   // without triggering a re-render on their change\n//   const requestRef = React.useRef();\n//   const previousTimeRef = React.useRef();\n//   const animate = (time) => {\n//     if (previousTimeRef.current != undefined) {\n//       const deltaTime = time - previousTimeRef.current;\n//       callback(deltaTime);\n//     }\n//     previousTimeRef.current = time;\n//     requestRef.current = requestAnimationFrame(animate);\n//   };\n//   React.useEffect(() => {\n//     requestRef.current = requestAnimationFrame(animate);\n//     return () => cancelAnimationFrame(requestRef.current);\n//   }, []); // Make sure the effect runs only once\n// };\n\nconst triangulateMesh = true;\n\nfunction drawPath(ctx, points, closePath) {\n  const region = new Path2D();\n  region.moveTo(points[0][0], points[0][1]);\n\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    region.lineTo(point[0], point[1]);\n  }\n\n  if (closePath) {\n    region.closePath();\n  }\n\n  ctx.stroke(region);\n}\n\nconst FaceTracker = ({\n  videoRef,\n  userId,\n  stream,\n  connected\n}) => {\n  const [count, setCount] = React.useState(0);\n  const [trackingEnabled, setTrackingEnabled] = useState(true);\n  const [videoLoaded, setVideoLoaded] = useState(false);\n  const [uuid, setUuid] = useState(null);\n  let faces = [];\n  let model = null;\n  let ctx, videoWidth, videoHeight, video, canvas;\n  useEffect(() => {\n    console.log(\"useEffect FaceTracker\");\n    console.log({\n      stream\n    });\n    if (_isNil(stream)) return;\n\n    _init();\n  }, [stream]);\n\n  async function _init() {\n    model = await facemesh.load({\n      maxFaces: 1\n    }); // Pass in a video stream to the model to obtain\n    // an array of detected faces from the MediaPipe graph.\n    // video = document.querySelector(\"video\");\n\n    video = document.getElementById(`video-${userId}`);\n    video.srcObject = stream;\n    video.addEventListener(\"playing\", function () {\n      setTimeout(function () {\n        console.log(\"Stream dimensions: \" + video.videoWidth + \"x\" + video.videoHeight);\n      }, 500);\n    });\n    video.addEventListener(\"loadeddata\", async event => {\n      console.log(\"Yay! The readyState just increased to  \" + \"HAVE_CURRENT_DATA or greater for the first time.\");\n      videoWidth = video.videoWidth;\n      videoHeight = video.videoHeight;\n      video.width = videoWidth;\n      video.height = videoHeight;\n      canvas = document.getElementById(`output-${userId}`);\n      canvas.width = videoWidth * 2;\n      canvas.height = videoHeight * 2; // const canvasContainer = document.querySelector(\".canvas-wrapper\");\n      // canvasContainer.style = `width: ${videoWidth}px; height: ${videoHeight}px`;\n\n      ctx = canvas.getContext(\"2d\");\n      ctx.translate(canvas.width, 0);\n      ctx.scale(-1, 1);\n      ctx.fillStyle = \"#32EEDB\";\n      ctx.strokeStyle = \"#32EEDB\";\n      ctx.lineWidth = 0.5;\n      setVideoLoaded(true);\n      renderPrediction();\n    });\n  }\n\n  async function renderPrediction() {\n    const predictions = await model.estimateFaces(video);\n    ctx.drawImage(video, 0, 0, videoWidth * 2, videoHeight * 2, 0, 0, canvas.width * 2, canvas.height * 2);\n\n    if (trackingEnabled) {\n      if (predictions.length > 0) {\n        predictions.forEach(prediction => {\n          // const keypoints = prediction.scaledMesh;\n          const keypoints = prediction.scaledMesh.map(set => set.map(c => c * 2));\n\n          if (triangulateMesh) {\n            for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n              const points = [TRIANGULATION[i * 3], TRIANGULATION[i * 3 + 1], TRIANGULATION[i * 3 + 2]].map(index => keypoints[index]);\n              drawPath(ctx, points, true);\n            }\n          } else {\n            for (let i = 0; i < keypoints.length; i++) {\n              const x = keypoints[i][0];\n              const y = keypoints[i][1];\n              ctx.beginPath();\n              ctx.arc(x, y, 1\n              /* radius */\n              , 0, 2 * Math.PI);\n              ctx.fill();\n            }\n          }\n        });\n      }\n    }\n\n    requestAnimationFrame(renderPrediction);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: \"flex\",\n      flex: 1,\n      border: \"2px solid red\",\n      position: \"relative\",\n      alignItems: \"center\",\n      justifyContent: \"center\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 154,\n      columnNumber: 5\n    }\n  }, connected ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"video\", {\n    id: `video-${userId}`,\n    autoPlay: true,\n    muted: true // ref={videoRef}\n    ,\n    playsInline: true,\n    style: {\n      WebkitTransform: \"scaleX(-1)\",\n      transform: \"scaleX(-1)\",\n      visibility: \"hidden\",\n      // display: \"none\",\n      width: \"2px\",\n      height: \"2px\",\n      border: \"3px solid green\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 11\n    }\n  }), /*#__PURE__*/React.createElement(\"canvas\", {\n    id: `output-${userId}` // style={{ position: \"absolute\", top: 0, left: 0, zIndex: 1000 }}\n    ,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 182,\n      columnNumber: 11\n    }\n  })) : /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 188,\n      columnNumber: 9\n    }\n  }, \"Waiting for connection...\"));\n};\n\nexport default FaceTracker;","map":{"version":3,"sources":["/Users/craigpickard/Dev/web/hbo-client/src/components/FaceTracker.js"],"names":["React","useEffect","useState","Fragment","facemesh","_isNil","TRIANGULATION","findByLabelText","triangulateMesh","drawPath","ctx","points","closePath","region","Path2D","moveTo","i","length","point","lineTo","stroke","FaceTracker","videoRef","userId","stream","connected","count","setCount","trackingEnabled","setTrackingEnabled","videoLoaded","setVideoLoaded","uuid","setUuid","faces","model","videoWidth","videoHeight","video","canvas","console","log","_init","load","maxFaces","document","getElementById","srcObject","addEventListener","setTimeout","event","width","height","getContext","translate","scale","fillStyle","strokeStyle","lineWidth","renderPrediction","predictions","estimateFaces","drawImage","forEach","prediction","keypoints","scaledMesh","map","set","c","index","x","y","beginPath","arc","Math","PI","fill","requestAnimationFrame","display","flex","border","position","alignItems","justifyContent","WebkitTransform","transform","visibility"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, Fragment } from \"react\";\nimport * as facemesh from \"@tensorflow-models/facemesh\";\nimport _isNil from \"lodash/isNil\";\n\nimport { TRIANGULATION } from \"./triangulation\";\nimport { findByLabelText } from \"@testing-library/react\";\n\n// const useAnimationFrame = (callback) => {\n//   // Use useRef for mutable variables that we want to persist\n//   // without triggering a re-render on their change\n//   const requestRef = React.useRef();\n//   const previousTimeRef = React.useRef();\n\n//   const animate = (time) => {\n//     if (previousTimeRef.current != undefined) {\n//       const deltaTime = time - previousTimeRef.current;\n//       callback(deltaTime);\n//     }\n//     previousTimeRef.current = time;\n//     requestRef.current = requestAnimationFrame(animate);\n//   };\n\n//   React.useEffect(() => {\n//     requestRef.current = requestAnimationFrame(animate);\n//     return () => cancelAnimationFrame(requestRef.current);\n//   }, []); // Make sure the effect runs only once\n// };\n\nconst triangulateMesh = true;\n\nfunction drawPath(ctx, points, closePath) {\n  const region = new Path2D();\n  region.moveTo(points[0][0], points[0][1]);\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    region.lineTo(point[0], point[1]);\n  }\n\n  if (closePath) {\n    region.closePath();\n  }\n  ctx.stroke(region);\n}\n\nconst FaceTracker = ({ videoRef, userId, stream, connected }) => {\n  const [count, setCount] = React.useState(0);\n  const [trackingEnabled, setTrackingEnabled] = useState(true);\n  const [videoLoaded, setVideoLoaded] = useState(false);\n  const [uuid, setUuid] = useState(null);\n\n  let faces = [];\n  let model = null;\n  let ctx, videoWidth, videoHeight, video, canvas;\n\n  useEffect(() => {\n    console.log(\"useEffect FaceTracker\");\n    console.log({ stream });\n    if (_isNil(stream)) return;\n    _init();\n  }, [stream]);\n\n  async function _init() {\n    model = await facemesh.load({ maxFaces: 1 });\n\n    // Pass in a video stream to the model to obtain\n    // an array of detected faces from the MediaPipe graph.\n    // video = document.querySelector(\"video\");\n    video = document.getElementById(`video-${userId}`);\n    video.srcObject = stream;\n    video.addEventListener(\"playing\", function () {\n      setTimeout(function () {\n        console.log(\n          \"Stream dimensions: \" + video.videoWidth + \"x\" + video.videoHeight\n        );\n      }, 500);\n    });\n\n    video.addEventListener(\"loadeddata\", async (event) => {\n      console.log(\n        \"Yay! The readyState just increased to  \" +\n          \"HAVE_CURRENT_DATA or greater for the first time.\"\n      );\n      videoWidth = video.videoWidth;\n      videoHeight = video.videoHeight;\n      video.width = videoWidth;\n      video.height = videoHeight;\n\n      canvas = document.getElementById(`output-${userId}`);\n      canvas.width = videoWidth * 2;\n      canvas.height = videoHeight * 2;\n      // const canvasContainer = document.querySelector(\".canvas-wrapper\");\n      // canvasContainer.style = `width: ${videoWidth}px; height: ${videoHeight}px`;\n\n      ctx = canvas.getContext(\"2d\");\n      ctx.translate(canvas.width, 0);\n      ctx.scale(-1, 1);\n      ctx.fillStyle = \"#32EEDB\";\n      ctx.strokeStyle = \"#32EEDB\";\n      ctx.lineWidth = 0.5;\n      setVideoLoaded(true);\n      renderPrediction();\n    });\n  }\n\n  async function renderPrediction() {\n    const predictions = await model.estimateFaces(video);\n    ctx.drawImage(\n      video,\n      0,\n      0,\n      videoWidth * 2,\n      videoHeight * 2,\n      0,\n      0,\n      canvas.width * 2,\n      canvas.height * 2\n    );\n\n    if (trackingEnabled) {\n      if (predictions.length > 0) {\n        predictions.forEach((prediction) => {\n          // const keypoints = prediction.scaledMesh;\n          const keypoints = prediction.scaledMesh.map((set) =>\n            set.map((c) => c * 2)\n          );\n          if (triangulateMesh) {\n            for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n              const points = [\n                TRIANGULATION[i * 3],\n                TRIANGULATION[i * 3 + 1],\n                TRIANGULATION[i * 3 + 2],\n              ].map((index) => keypoints[index]);\n\n              drawPath(ctx, points, true);\n            }\n          } else {\n            for (let i = 0; i < keypoints.length; i++) {\n              const x = keypoints[i][0];\n              const y = keypoints[i][1];\n\n              ctx.beginPath();\n              ctx.arc(x, y, 1 /* radius */, 0, 2 * Math.PI);\n              ctx.fill();\n            }\n          }\n        });\n      }\n    }\n\n    requestAnimationFrame(renderPrediction);\n  }\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        flex: 1,\n        border: \"2px solid red\",\n        position: \"relative\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n      }}\n    >\n      {connected ? (\n        <>\n          <video\n            id={`video-${userId}`}\n            autoPlay\n            muted\n            // ref={videoRef}\n            playsInline\n            style={{\n              WebkitTransform: \"scaleX(-1)\",\n              transform: \"scaleX(-1)\",\n              visibility: \"hidden\",\n              // display: \"none\",\n              width: \"2px\",\n              height: \"2px\",\n              border: \"3px solid green\",\n            }}\n          />\n          <canvas\n            id={`output-${userId}`}\n            // style={{ position: \"absolute\", top: 0, left: 0, zIndex: 1000 }}\n          />\n        </>\n      ) : (\n        <div>Waiting for connection...</div>\n      )}\n    </div>\n  );\n};\n\nexport default FaceTracker;\n"]},"metadata":{},"sourceType":"module"}