{"ast":null,"code":"var _jsxFileName = \"/Users/craigpickard/Dev/web/hbo-client/src/components/FaceTracker.js\";\nimport React, { useEffect, useState } from \"react\";\nimport * as facemesh from \"@tensorflow-models/facemesh\";\nimport _isNil from \"lodash/isNil\";\nimport { TRIANGULATION } from \"./triangulation\"; // const useAnimationFrame = (callback) => {\n//   // Use useRef for mutable variables that we want to persist\n//   // without triggering a re-render on their change\n//   const requestRef = React.useRef();\n//   const previousTimeRef = React.useRef();\n//   const animate = (time) => {\n//     if (previousTimeRef.current != undefined) {\n//       const deltaTime = time - previousTimeRef.current;\n//       callback(deltaTime);\n//     }\n//     previousTimeRef.current = time;\n//     requestRef.current = requestAnimationFrame(animate);\n//   };\n//   React.useEffect(() => {\n//     requestRef.current = requestAnimationFrame(animate);\n//     return () => cancelAnimationFrame(requestRef.current);\n//   }, []); // Make sure the effect runs only once\n// };\n\nconst triangulateMesh = true;\n\nfunction drawPath(ctx, points, closePath) {\n  const region = new Path2D();\n  region.moveTo(points[0][0], points[0][1]);\n\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    region.lineTo(point[0], point[1]);\n  }\n\n  if (closePath) {\n    region.closePath();\n  }\n\n  ctx.stroke(region);\n}\n\nconst FaceTracker = ({\n  userId,\n  stream\n}) => {\n  const [count, setCount] = React.useState(0);\n  const [videoLoaded, setVideoLoaded] = useState(false);\n  const [uuid, setUuid] = useState(null);\n  let faces = [];\n  let model = null;\n  let ctx, videoWidth, videoHeight, video, canvas;\n  useEffect(() => {\n    console.log(\"wolfy\");\n    console.log({\n      stream\n    });\n    if (stream === null) return;\n\n    _init();\n  }, [stream]);\n\n  async function _init() {\n    model = await facemesh.load({\n      maxFaces: 1\n    }); // Pass in a video stream to the model to obtain\n    // an array of detected faces from the MediaPipe graph.\n    // video = document.querySelector(\"video\");\n\n    console.log({\n      userId\n    });\n    video = document.getElementById(`video-${userId}`);\n    console.log({\n      stream\n    });\n    video.srcObject = stream;\n    video.addEventListener(\"loadeddata\", async event => {\n      console.log(\"Yay! The readyState just increased to  \" + \"HAVE_CURRENT_DATA or greater for the first time.\");\n      videoWidth = video.videoWidth;\n      videoHeight = video.videoHeight;\n      video.width = videoWidth;\n      video.height = videoHeight;\n      canvas = document.getElementById(`output-${userId}`);\n      canvas.width = videoWidth;\n      canvas.height = videoHeight;\n      const canvasContainer = document.querySelector(\".canvas-wrapper\");\n      canvasContainer.style = `width: ${videoWidth}px; height: ${videoHeight}px`;\n      ctx = canvas.getContext(\"2d\");\n      ctx.translate(canvas.width, 0);\n      ctx.scale(-1, 1);\n      ctx.fillStyle = \"#32EEDB\";\n      ctx.strokeStyle = \"#32EEDB\";\n      ctx.lineWidth = 0.5;\n      setVideoLoaded(true);\n      renderPrediction();\n    });\n  }\n\n  async function renderPrediction() {\n    const predictions = await model.estimateFaces(video);\n    ctx.drawImage(video, 0, 0, videoWidth, videoHeight, Math.floor(parseInt(userId) * canvas.width), Math.floor(parseInt(userId) * canvas.height), canvas.width, canvas.height); // ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    if (predictions.length > 0) {\n      predictions.forEach(prediction => {\n        const keypoints = prediction.scaledMesh;\n\n        if (triangulateMesh) {\n          for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n            const points = [TRIANGULATION[i * 3], TRIANGULATION[i * 3 + 1], TRIANGULATION[i * 3 + 2]].map(index => keypoints[index]);\n            drawPath(ctx, points, true);\n          }\n        } else {\n          for (let i = 0; i < keypoints.length; i++) {\n            const x = keypoints[i][0];\n            const y = keypoints[i][1];\n            ctx.beginPath();\n            ctx.arc(x, y, 1\n            /* radius */\n            , 0, 2 * Math.PI);\n            ctx.fill();\n          }\n        }\n      });\n    }\n\n    requestAnimationFrame(renderPrediction);\n  } //   useAnimationFrame(async (deltaTime) => {\n  //     // Pass on a function to the setter of the state\n  //     // to make sure we always have the latest state\n  //     console.log(\"animate\");\n  //     if (model !== null) faces = await model.estimateFaces(video);\n  //     // faces.forEach((face) => console.log(face.scaledMesh));\n  //     console.log(faces.length);\n  //   });\n\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"canvas-wrapper\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"video\", {\n    id: `video-${userId}`,\n    autoPlay: true,\n    muted: true // ref={videoRef}\n    ,\n    playsInline: true,\n    style: {\n      WebkitTransform: \"scaleX(-1)\",\n      transform: \"scaleX(-1)\",\n      visibility: \"hidden\",\n      width: \"auto\",\n      height: \"auto\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"canvas\", {\n    id: `output-${userId}`,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 7\n    }\n  }));\n};\n\nexport default FaceTracker;","map":{"version":3,"sources":["/Users/craigpickard/Dev/web/hbo-client/src/components/FaceTracker.js"],"names":["React","useEffect","useState","facemesh","_isNil","TRIANGULATION","triangulateMesh","drawPath","ctx","points","closePath","region","Path2D","moveTo","i","length","point","lineTo","stroke","FaceTracker","userId","stream","count","setCount","videoLoaded","setVideoLoaded","uuid","setUuid","faces","model","videoWidth","videoHeight","video","canvas","console","log","_init","load","maxFaces","document","getElementById","srcObject","addEventListener","event","width","height","canvasContainer","querySelector","style","getContext","translate","scale","fillStyle","strokeStyle","lineWidth","renderPrediction","predictions","estimateFaces","drawImage","Math","floor","parseInt","forEach","prediction","keypoints","scaledMesh","map","index","x","y","beginPath","arc","PI","fill","requestAnimationFrame","WebkitTransform","transform","visibility"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport * as facemesh from \"@tensorflow-models/facemesh\";\nimport _isNil from \"lodash/isNil\";\n\nimport { TRIANGULATION } from \"./triangulation\";\n\n// const useAnimationFrame = (callback) => {\n//   // Use useRef for mutable variables that we want to persist\n//   // without triggering a re-render on their change\n//   const requestRef = React.useRef();\n//   const previousTimeRef = React.useRef();\n\n//   const animate = (time) => {\n//     if (previousTimeRef.current != undefined) {\n//       const deltaTime = time - previousTimeRef.current;\n//       callback(deltaTime);\n//     }\n//     previousTimeRef.current = time;\n//     requestRef.current = requestAnimationFrame(animate);\n//   };\n\n//   React.useEffect(() => {\n//     requestRef.current = requestAnimationFrame(animate);\n//     return () => cancelAnimationFrame(requestRef.current);\n//   }, []); // Make sure the effect runs only once\n// };\n\nconst triangulateMesh = true;\n\nfunction drawPath(ctx, points, closePath) {\n  const region = new Path2D();\n  region.moveTo(points[0][0], points[0][1]);\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    region.lineTo(point[0], point[1]);\n  }\n\n  if (closePath) {\n    region.closePath();\n  }\n  ctx.stroke(region);\n}\n\nconst FaceTracker = ({ userId, stream }) => {\n  const [count, setCount] = React.useState(0);\n  const [videoLoaded, setVideoLoaded] = useState(false);\n  const [uuid, setUuid] = useState(null);\n\n  let faces = [];\n  let model = null;\n  let ctx, videoWidth, videoHeight, video, canvas;\n\n  useEffect(() => {\n    console.log(\"wolfy\");\n    console.log({ stream });\n    if (stream === null) return;\n    _init();\n  }, [stream]);\n\n  async function _init() {\n    model = await facemesh.load({ maxFaces: 1 });\n\n    // Pass in a video stream to the model to obtain\n    // an array of detected faces from the MediaPipe graph.\n    // video = document.querySelector(\"video\");\n    console.log({ userId });\n    video = document.getElementById(`video-${userId}`);\n    console.log({ stream });\n    video.srcObject = stream;\n    video.addEventListener(\"loadeddata\", async (event) => {\n      console.log(\n        \"Yay! The readyState just increased to  \" +\n          \"HAVE_CURRENT_DATA or greater for the first time.\"\n      );\n      videoWidth = video.videoWidth;\n      videoHeight = video.videoHeight;\n      video.width = videoWidth;\n      video.height = videoHeight;\n\n      canvas = document.getElementById(`output-${userId}`);\n      canvas.width = videoWidth;\n      canvas.height = videoHeight;\n      const canvasContainer = document.querySelector(\".canvas-wrapper\");\n      canvasContainer.style = `width: ${videoWidth}px; height: ${videoHeight}px`;\n\n      ctx = canvas.getContext(\"2d\");\n      ctx.translate(canvas.width, 0);\n      ctx.scale(-1, 1);\n      ctx.fillStyle = \"#32EEDB\";\n      ctx.strokeStyle = \"#32EEDB\";\n      ctx.lineWidth = 0.5;\n      setVideoLoaded(true);\n      renderPrediction();\n    });\n  }\n\n  async function renderPrediction() {\n    const predictions = await model.estimateFaces(video);\n    ctx.drawImage(\n      video,\n      0,\n      0,\n      videoWidth,\n      videoHeight,\n      Math.floor(parseInt(userId) * canvas.width),\n      Math.floor(parseInt(userId) * canvas.height),\n      canvas.width,\n      canvas.height\n    );\n\n    // ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    if (predictions.length > 0) {\n      predictions.forEach((prediction) => {\n        const keypoints = prediction.scaledMesh;\n\n        if (triangulateMesh) {\n          for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n            const points = [\n              TRIANGULATION[i * 3],\n              TRIANGULATION[i * 3 + 1],\n              TRIANGULATION[i * 3 + 2],\n            ].map((index) => keypoints[index]);\n\n            drawPath(ctx, points, true);\n          }\n        } else {\n          for (let i = 0; i < keypoints.length; i++) {\n            const x = keypoints[i][0];\n            const y = keypoints[i][1];\n\n            ctx.beginPath();\n            ctx.arc(x, y, 1 /* radius */, 0, 2 * Math.PI);\n            ctx.fill();\n          }\n        }\n      });\n    }\n    requestAnimationFrame(renderPrediction);\n  }\n\n  //   useAnimationFrame(async (deltaTime) => {\n  //     // Pass on a function to the setter of the state\n  //     // to make sure we always have the latest state\n  //     console.log(\"animate\");\n  //     if (model !== null) faces = await model.estimateFaces(video);\n  //     // faces.forEach((face) => console.log(face.scaledMesh));\n  //     console.log(faces.length);\n  //   });\n\n  return (\n    <div className=\"canvas-wrapper\">\n      <video\n        id={`video-${userId}`}\n        autoPlay\n        muted\n        // ref={videoRef}\n        playsInline\n        style={{\n          WebkitTransform: \"scaleX(-1)\",\n          transform: \"scaleX(-1)\",\n          visibility: \"hidden\",\n          width: \"auto\",\n          height: \"auto\",\n        }}\n      />\n      <canvas id={`output-${userId}`}></canvas>\n    </div>\n  );\n};\n\nexport default FaceTracker;\n"]},"metadata":{},"sourceType":"module"}